## 概要
`train.py` は「白黒のアニメ画像をカラーにする」しくみを練習するためのシンプルなサンプルです。画像を読み込み、モデルを学習し、結果を画像として保存するまでを一つのファイルで行います。

## 利用ライブラリと役割（やさしい説明）
- `os`, `sys`: ファイルやフォルダの場所を扱うための標準ライブラリ。`sys.path` を足して自分のモジュールを見つけやすくする。
- `pathlib`: パスを「文字列の足し算」ではなくオブジェクトとして安全に扱うための標準ライブラリ。
- `torch`（PyTorch）: ニューラルネットを作って学習するライブラリ。テンソル計算や自動微分を担当。
  - `torch.nn`: レイヤーや損失関数をまとめたサブパッケージ。
  - `torch.optim.Adam`: パラメータを少しずつ良い方向に動かすアルゴリズム（最適化手法）。
  - `torch.utils.data.DataLoader`: データを小分け（バッチ）にして渡す便利クラス。
  - `torch.utils.data.random_split`: データを学習用とテスト用にざっくり分けるヘルパー。
  - `torch.no_grad()`: 推論中に「学習のための計算」を止めて軽くするスイッチ。
  - `torch.cuda.is_available`, `torch.backends.mps.is_available`: GPU が使えるかどうかを調べる。
- `torchvision.transforms.functional.to_pil_image`: PyTorch のテンソルを PIL 画像に変換する関数。
- `PIL.Image`, `PIL.ImageDraw`, `PIL.ImageFont`: 画像を作ったり、四角や文字を書き込んだりするためのライブラリ。
- 自作モジュール `dataset`:
  - `HFAFPairDataset`: 1 枚の画像から「カラー」と「グレースケール」のペアを作って返すクラス。
  - `basic_transforms`: 画像をリサイズして正規化する基本の前処理セット。
- 自作モジュール `models`:
  - `build_models`: カラー化用のジェネレーターと、それを見分けるディスクリミネーターを作って返す関数。

## スクリプト内の主な関数（やさしい説明）
### `make_dataloaders(data_dir, batch_size, image_size=96, test_ratio=0.2, seed=42)`
- 画像フォルダを受け取り、カラー/グレースケールのペアを返す `HFAFPairDataset` を作ります。
- 画像を小さくして数字に変える「前処理」を `basic_transforms` で用意し、カラーと白黒それぞれに適用します。
- データを学習用とテスト用に分けます（デフォルトで 8:2）。同じ分け方を再現できるよう乱数シードを固定します。
- 学習用とテスト用の `DataLoader` を返します。学習用は順番をシャッフルし、テスト用は固定のまま渡します。
- 画像が 2 枚未満ならエラーにして早めに気づけるようにしています。

### `get_device()`
- 使えるデバイスを「CUDA（NVIDIA GPU）→MPS（Apple GPU）→CPU」の順で探し、文字列で返します。
- GPU が無い環境でも自動で CPU に切り替わるので、手動の切り替えは不要です。

### `train(train_loader, epochs=1, learning_rate=2e-4, device=None)`
- モデルを作る: `build_models` でジェネレーター（色をつける役）とディスクリミネーター（本物/偽物の判定役）を用意し、選ばれたデバイスに送ります。
- 損失（ズレの測り方）:
  - `BCEWithLogitsLoss`: 「本物/偽物」の判定を学習するための二値分類の損失。
  - `L1Loss`（100倍して重視）: 生成した色と本物の色がどれだけ違うかを画素ごとに測ります。
- 最適化（パラメータ更新）: `Adam` でパラメータを少しずつ調整します。`learning_rate` で一歩の大きさを決めます。
- 学習の流れ（1エポック）:
  1. 学習データをバッチごとに取り出す。
  2. ジェネレーターを更新（色をつける能力を上げる）。
  3. ディスクリミネーターを更新（本物/偽物を見分ける能力を上げる）。
  4. 10 ステップごとに損失を `print` で表示し、進み具合を確認。
- 学習が終わったら、学習済みジェネレーターと使ったデバイス名を返します。

### `generate(generator, test_loader, device, output_dir=None, max_columns=10)`
- テストセットから最大 `max_columns` 枚を使い、3 行（グレースケール/生成結果/元画像）を横に並べた画像を作ります。
- 推論モードに切り替え、学習時の正規化を元に戻して 0〜1 の範囲に直します。
- PIL で真っ白のキャンバスを作り、`paste` でタイルを配置し、ラベルを描きます。
- `output_dir`（指定が無ければカレントディレクトリ）に `v00_samples_test.png` として保存し、パスを返します。データが無い場合は `None` を返します。

### `main()`
- どこから実行してもデータを見つけられるよう、スクリプトから 3 階層上を「プロジェクトルート」とみなし、`data/HFAF-small` を指し示します。
- まとめて設定する項目（エポック数、バッチサイズ、学習率、画像サイズ）はここに集め、変更しやすくしています。
- 流れはシンプルに 3 ステップ:
  1. `make_dataloaders` でデータを準備する。
  2. `train` でモデルを学習する。
  3. `generate` で結果画像を保存する。
- **なぜ `main` を分けるのか**  
  - 「ここから処理が始まるよ」という入口を一か所にまとめ、設定を変更するときに探しやすくするためです。  
  - 関数に分けると、テストや再利用がしやすくなり、途中の処理だけを差し替えることも簡単です。
- **`if __name__ == "__main__":` の意味**  
  - このファイルを「直接」実行したときだけ、`main()` を動かす、という合図です。  
  - 逆に、別のファイルから `import` されたときは `main()` を呼ばず、関数やクラスだけを提供するようにできます。  
  - これにより、「ライブラリとして使う場合」と「スクリプトとして単体で動かす場合」を切り替えられます。

## 主要なPython文法・構文（初心者向けのやさしい解説）
- **モジュールとインポート**  
  - 「道具箱を持ってくる」イメージです。`import math` と書けば `math` の中の道具が使えます。  
  - 必要な道具だけを短く呼びたいときは `from math import sqrt` のように書きます。  
  - 自分で作ったファイルを読み込みたいとき、見つからない場合は `sys.path` にそのフォルダを足して「ここも探してね」と教えます。

- **関数の作り方（`def`）**  
  - 「入力をもらって処理し、必要なら結果を返す箱」です。  
  - 例:  
    ```python
    def add(a, b=0):
        return a + b
    ```
    `b=0` のようにデフォルト値をつけると、呼び出し側は省略できます。  
  - 返り値が2つ以上あるときは `return x, y` のようにカンマで並べ、受け取り側は `u, v = add_and_mul(...)` のように二つ同時に受け取ります。

- **クラスの作り方（`class`）**  
  - 「同じ性質をもつものをまとめる設計図」です。  
  - 例:  
    ```python
    class Counter:
        def __init__(self, start=0):
            self.value = start
        def inc(self):
            self.value += 1
    ```
    `__init__` は作られた直後に走る初期化。`self` は「自分自身」を指すお約束の名前です。  
  - 使うときは `c = Counter()`、メソッド呼び出しは `c.inc()` のように書きます。

- **for文（繰り返し）**  
  - `for x in [1, 2, 3]:` のように書き、リストなどの要素を順番に取り出します。  
  - 回数を指定したいときは `for i in range(5):` のように `range` を使います。0 から 4 まで5回繰り返します。  
  - 順番だけでなく番号も欲しいときは `for idx, item in enumerate(items):` と書くと、`idx` が 0,1,2... と進み、`item` が要素になります。

- **if / elif / else（分岐）**  
  - 条件によってやることを変える基本の形です。  
    ```python
    if score >= 80:
        grade = "A"
    elif score >= 60:
        grade = "B"
    else:
        grade = "C"
    ```
  - 上から順に条件をチェックし、最初に当てはまったところのブロックだけが実行されます。

- **while文（条件付きの繰り返し）**  
  - 条件が真の間だけ続けるループです。回数が決まっていないときに使います。  
    ```python
    while not_done:
        do_something()
    ```
  - 無限ループにならないよう、どこかで条件が変わるように注意します。

- **with文（コンテキストマネージャ）**  
  - 「使い終わったら片付ける」を自動でやってくれる枠です。  
    ```python
    with open("file.txt") as f:
        text = f.read()
    ```
  - ブロックを抜けた瞬間にファイルが閉じられます。エラーが起きても後片付けが走るので安全です。`torch.no_grad()` も同じしくみです。

- **try / except / finally（例外処理）**  
  - エラーが起こりそうな処理を `try` に入れ、失敗したら `except` で代わりの処理やメッセージを出します。  
  - `raise ValueError("理由")` のように自分でエラーを投げることもできます。  
  - `finally` は、成功しても失敗しても最後に必ず走らせたい片付けを書きます（このスクリプトでは未使用）。

- **f文字列（フォーマット文字列）**  
  - 文字列の中に変数を埋め込む楽な書き方です。  
    ```python
    name = "Taro"
    print(f"Hello {name}")
    ```
  - `f"{value:.2f}"` のように小数点以下2桁などの書式指定も簡単です。

- **リストと基本操作**  
  - `numbers = [1, 2, 3]` のように作成。  
  - `numbers.append(4)` で末尾に追加、`len(numbers)` で長さ、`numbers[0]` で 0 番目の要素を取り出せます。  
  - いろいろな型を混ぜて入れられますが、扱いやすさのため同じ型でそろえるのが一般的です。

- **パス操作（ファイルやフォルダの道の指定）**  
  - `pathlib.Path` を使うと `Path("data") / "file.txt"` のように `/` でつなげて書け、OS が違っても同じ書き方で動きます。  
  - 文字列だけで扱いたいときは `os.path.join(base, "file.txt")` を使うと区切り文字を気にせず結合できます。

- **print文**  
  - `print("hello")` で標準出力に表示。デフォルトで最後に改行がつきます。  
  - 区切りや改行を変えたいときは `print("a", "b", sep=",", end="")` のように `sep` と `end` を指定します。  
  - f文字列と組み合わせると状況説明を簡単に出せます。

- **スコープ（変数の届く範囲）と名前解決**  
  - 変数は「今いるブロックの中→一つ外→さらに外…」という順で探されます。これを LEGB（Local, Enclosing, Global, Built-in）と呼びます。  
  - 関数の外で作った変数を中で書き換えたい場合は `global` を宣言しますが、できるだけ引数・戻り値で受け渡す方が安全で分かりやすいです。

（このプロジェクトではラムダ式や型アノテーションは使っていません。必要になったら別途学ぶと理解が深まります。）

## 実行手順の流れ
1. `make_dataloaders` が画像を読み込み、学習用とテスト用に分けます。  
2. `train` がモデルを学習し、色をつける力と見分ける力を身につけます。  
3. `generate` がテストセットを使って結果画像を作り、ファイルに保存します。  
4. ターミナルで `python -m coloring.src.version00.train` を実行すれば、1〜3 がまとめて動きます。  

このドキュメントは、初心者でも「何をしているのか」をイメージしやすいよう、やさしい言葉でまとめています。
